ТЕХНИЧЕСКОЕ ЗАДАНИЕ ДЛЯ МОДУЛЯ iterate
Назначение

Модуль iterate — это единственная стадия вычисления квадратного корня.
Он получает уже нормализованное, гарантированно неотрицательное число (в формате внутреннего представления), выполняет digit-by-digit (restoring) алгоритм корня, и выдает нормализованный результат (мантисса 11 бит + экспонента).

Модуль НЕ должен обрабатывать отрицательные числа, NaN или ±Inf.
Все такие случаи были обработаны модулями special и normalize.
iterate получает эти сигналы лишь для корректной передачи внешним модулям.

Интерфейс модуля
Входы
clk         — синхронный такт
enable      — общий разрешающий сигнал (0 = полный сброс внутреннего состояния)
n_valid     — однократный импульс запуска вычисления (из normalize)

is_nan_in   — special: число было NaN
is_pinf_in  — special: +Inf
is_ninf_in  — special: -Inf

is_num      — 1, если вход — корректное число ≥ 0 (normal или subnormal)

mant_in[10:0] — нормализованная мантисса 1.xxxxxxxxxxx (или нормализованная subnormal)
exp_in [6:0]  — unbiased экспонента (уже скорректированная в normalize)

Выходы
it_valid   — 1 каждый такт, когда модуль выдаёт промежуточную мантиссу
result     — 1 ровно один такт в самом конце, когда sqrt готов

sign_out   — всегда 0, кроме special случаев (которые просто повторяются)
exp_out    — unbiased exponent результата sqrt
mant_out   — 11-битная мантисса sqrt перед нормализацией для pack

Общее поведение
1. Поведение при enable = 0

Полный сброс внутреннего состояния.

Все регистры (radicand, remainder, root, счётчики) должны обнуляться.

Выходы: sign_out=0, exp_out=0, mant_out=0.

Не выдавать it_valid и result.

2. Обработка special случаев

Если при n_valid=1 входные сигналы показывают special случай (is_nan_in, is_pinf_in, is_ninf_in, is_num=0), то:

2.1 Выдача результата за 1 такт

Без итераций.

Сразу установить it_valid = 1 и result = 1.

Передать наружу фиксированное значение:

Для NaN: sign_out=1, exp_out=16, mant_out = quiet bit

Для +Inf: sign_out=0, exp_out=16, mant_out=0

Для -Inf: sign_out=1, exp_out=16, mant_out=quiet bit

Для not-a-number input (например отрицательное): canonical NaN

2.2 Прекращение работы

Не входить в режим итераций.

active = 0.

3. Основной алгоритм (digit-by-digit restoring sqrt)
3.1 Подготовка при запуске (n_valid=1 и is_num=1)

Проверить exp_in на чётность:

если exp_in нечётный → выровнять мантиссу:
work_mant = mant_in << 1, work_exp = exp_in - 1

если чётный →
work_mant = mant_in, work_exp = exp_in

Мантисса work_mant имеет формат 11 или 12 бит, но radicand всегда формируется как:

radicand = work_mant << (2*ITER_MAX)


где ITER_MAX = 11.

remainder = 0

root = 0

iter_left = ITER_MAX

exp_out = work_exp >>> 1
(т.е. sqrt(exp) = exp/2 без округления)

Выдать:

sign_out = 0
it_valid = 0
result   = 0
active = 1

4. Итерационный процесс (одна итерация на каждый clk при active=1)

Каждый такт (пока iter_left > 0):

4.1 Формирование remainder
remainder = (remainder << 2) + next_top2_bits_of_radicand
radicand <<= 2

4.2 Формирование trial
trial = (root << 1) + 1


С учётом приведения ширин trial должен совпадать по разрядам с remainder.

4.3 Выбор бита корня
if remainder >= trial:
    remainder = remainder - trial
    root = (root << 1) | 1
else:
    root = (root << 1) | 0

4.4 Генерация выходов

Каждую итерацию:

it_valid = 1

mant_out = root << (iter_left - 1)
(текущая оценка sqrt)

4.5 Финальный такт

Если iter_left == 1:

После вычисления:

result = 1

active = 0

iter_left = 0

Иначе:

iter_left = iter_left - 1

5. Итог

В конце работы:

Результирующая мантисса — последняя mant_out.

Результирующая экспонента — exp_out = work_exp >> 1

sign_out = 0.

Модуль ждёт нового запуска n_valid.

Ограничения

Никакой комбинаторной логики поверх больших данных вне регистрационного пути.

Все вычисления — только в always @(posedge clk).

Ни один special случай не должен попадать в алгоритм — он обязан быть обработан до запуска итераций.

Модуль не занимается нормализацией и упаковкой — только sqrt мантиссы + sqrt экспоненты.